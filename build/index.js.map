{
  "version": 3,
  "sources": ["../src/index.ts"],
  "sourcesContent": [
    "/**\n * Checks if an index exists in an array-like object.\n * @param {unknown | number} idx - The index to check.\n * @param {ArrayLike<T>} array - The array-like object to check against.\n * @returns {boolean} True if the index exists in the array, false otherwise.\n * @example\n * const array = [1, 2, 3];\n * isIndexOf(1, array); // true\n * isIndexOf(3, array); // false\n */\nexport const isIndexOf = <T>(idx: unknown | number, array: ArrayLike<T>): boolean => {\n    const numberIdx = typeof idx === 'number' ? idx : Number(idx);\n    return !isNaN(numberIdx) && Array.isArray(array) && array.length > 0 && numberIdx >= 0 && numberIdx < array.length;\n}\n\n/**\n * Checks if a value is an array-like object.\n * @param {unknown} array - The value to check.\n * @returns {boolean} True if the value is array-like, false otherwise.\n * @example\n * isArray([1, 2, 3]); // true\n * isArray('not an array'); // false\n */\nexport const isArray = <T, A = ArrayLike<T>>(array: unknown): array is A => {\n    return Array.isArray(array);\n}\n\n/**\n * Checks if a value is indexable (array-like).\n * @param {unknown} array - The value to check.\n * @returns {boolean} True if the value is indexable, false otherwise.\n * @example\n * isIndexable([1, 2, 3]); // true\n * isIndexable('not indexable'); // false\n */\nexport const isIndexable = <T, A = ArrayLike<T>>(array: unknown): array is A => {\n    return Array.isArray(array) && array.length != 0;\n}\n\n/**\n * Throttles a function so that it can only be called once every specified delay.\n * @param {((...args: any[]) => void} fn - The function to throttle.\n * @param {number} delay - The delay in milliseconds.\n * @returns {((...args: any[]) => void} The throttled function.\n * @example\n * const throttledLog = throttle(() => console.log('Throttled!'), 1000);\n * window.addEventListener('resize', throttledLog);\n */\nexport const throttle = <T extends (...args: any[]) => void>(fn: T, delay: number) => {\n    let timer: ReturnType<typeof setTimeout> | null = null;\n    return (...args: Parameters<T>) => {\n        if (!timer) {\n            fn(...args);\n            timer = setTimeout(() => {\n                timer = null;\n            }, delay);\n        }\n    }\n}\n\n/**\n * Debounces a function so that it can only be called after a specified delay since the last call.\n * @param {(...args: any[]) => void} fn - The function to debounce.\n * @param {number} delay - The delay in milliseconds.\n * @returns {(...args: any[]) => void} The debounced function.\n * @example\n * const debouncedLog = debounce((a: string) => console.log(`Debounced: ${a}`), 1000);\n * window.addEventListener('scroll', (evt: Event) => debouncedLog(evt.type));\n */\nexport const debounce = <T extends (...args: any[]) => void>(fn: T, delay: number) => {\n    let timer: ReturnType<typeof setTimeout> | null = null;\n    return (...args: Parameters<T>) => {\n        if (timer) {\n            clearTimeout(timer);\n        }\n        timer = setTimeout(() => {\n            fn(...args);\n        }, delay);\n    }\n}\n\n/**\n * Delays execution for a specified number of milliseconds.\n * @param {number} ms - The number of milliseconds to sleep.\n * @returns {Promise<void>} A promise that resolves after the delay.\n * @example\n * async function run() {\n *   await sleep(1000);\n *   console.log('1 second later');\n * }\n * run();\n */\nexport const sleep = (ms: number) => new Promise(resolve => setTimeout(resolve, ms))\n\n/**\n * Validates if a string is a valid email address.\n * @param {string} email - The email string to validate.\n * @returns {boolean} True if the email is valid, false otherwise.\n * @example\n * isEmail('test@example.com'); // true\n * isEmail('invalid-email'); // false\n */\nexport const isEmail = (email: string) => {\n    return /^\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*$/.test(email);\n}\n\n/**\n * a regular expression for validating email addresses.\n * @example\n * emailRegex.test('test@example.com'); // true\n */\nexport const emailRegex = /^\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*$/;\n\n/**\n * Validates if a string is a valid phone number.\n * @param {string} phone - The phone string to validate.\n * @returns {boolean} True if the phone is valid, false otherwise.\n * @example\n * isPhone('+1234567890'); // true\n * isPhone('invalid-phone'); // false\n */\nexport const isPhone = (phone: string) => {\n    return /^1[3456789]\\d{9}$/.test(phone);\n}\n\n/**\n * Removes an item from an array.\n * @param {T} item - The item to remove.\n * @param {T[]} array - The array to remove the item from.\n * @example\n * const array = [1, 2, 3];\n * remove(2, array);\n * console.log(array); // [1, 3]\n */\nexport const remove = <T>(item: T, array: T[]) => {\n    const idx = array.indexOf(item);\n    if (idx >= 0) {\n        array.splice(idx, 1);\n    }\n}\n\n/**\n * Removes an item using the index from an array.\n * @param {T} item - The index of item to remove.\n * @param {T[]} array - The array to remove the item from.\n * @example\n * const array = [1, 2, 3];\n * removeAtIndex(1, array);\n * console.log(array); // [1, 3]\n */\nexport const removeAtIndex = <T>(array: T[], index: number) => {\n    return array.splice(index, 1);\n}\n\n/**\n * Merges two arrays into one.\n * @param {T[]} a - The first array.\n * @param {T[]} b - The second array.\n * @returns {T[]} The merged array.\n * @example\n * const array1 = [1, 2];\n * const array2 = [3, 4];\n * const merged = merge(array1, array2);\n * console.log(merged); // [1, 2, 3, 4]\n */\nexport const merge = <T>(a: T[], b: T[]) => [...a, ...b];\n\n\n/**\n * Removes duplicate items from an array.\n * @param {T[]} array - The array to make unique.\n * @returns {T[]} A new array with unique items.\n * @example\n * const array = [1, 1, 2, 2, 3];\n * const uniqueArray = unique(array);\n * console.log(uniqueArray); // [1, 2, 3]\n */\nexport const unique = <T>(array: T[]) => {\n    return Array.from(new Set(array));\n}\n\n/**\n * Generates a random number between min and max.\n * @param {number} min - The minimum number.\n * @param {number} max - The maximum number.\n * @returns {number} A random number between min and max.\n * @example\n * const randomNumber = random(1, 10);\n * console.log(randomNumber); // e.g., 7\n */\nexport const random = (min: number, max: number) => {\n    return Math.floor(Math.random() * (max - min + 1) + min);\n}\n\n/**\n * Checks if a value is a string.\n * @param {unknown} value - The value to check.\n * @returns {boolean} True if the value is a string, false otherwise.\n * @example\n * isString('hello'); // true\n * isString(123); // false\n */\nexport const isString = (value: unknown): value is string => typeof value === 'string';\n\n/**\n * Checks if a value is a number.\n * @param {unknown} value - The value to check.\n * @returns {boolean} True if the value is a number, false otherwise.\n * @example\n * isNumber(123); // true\n * isNumber('123'); // false\n */\nexport const isNumber = (value: unknown): value is number => typeof value === 'number';\n\n/**\n * Shuffles an array.\n * @param {T[]} array - The array to shuffle.\n * @returns {T[]} The shuffled array.\n * @example\n * const array = [1, 2, 3, 4];\n * const shuffled = shuffle(array);\n * console.log(shuffled); // e.g., [3, 1, 4, 2]\n */\nexport const shuffle = <T>(array: T[]): T[] => {\n    let m = array.length, t: T, i: number;\n    while (m) {\n        i = Math.floor(Math.random() * m--);\n        t = array[m];\n        array[m] = array[i];\n        array[i] = t;\n    }\n    return array;\n};\n\n/**\n * Deep clones an object or array.\n * @param {T} obj - The object or array to clone.\n * @returns {T} A deep clone of the object or array.\n * @example\n * const original = { a: 1, b: { c: 2 } };\n * const clone = deepClone(original);\n * console.log(clone); // { a: 1, b: { c: 2 } }\n */\nexport const deepClone = <T>(obj: T): T => JSON.parse(JSON.stringify(obj));\n\n/**\n * Converts a string to title case.\n * @param {string} str - The string to convert.\n * @returns {string} The title-cased string.\n * @example\n * toTitleCase('hello world'); // 'Hello World'\n */\nexport const toTitleCase = (str: string): string =>\n    str.replace(/\\w\\S*/g, (txt) => txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase());\n\n/**\n * Groups an array of objects by a key.\n * @param {T[]} array - The array to group.\n * @param {keyof T} key - The key to group by.\n * @returns {Record<string, T[]>} An object with keys representing group names and values being arrays of grouped items.\n * @example\n * const array = [{ category: 'A', value: 1 }, { category: 'B', value: 2 }, { category: 'A', value: 3 }];\n * const grouped = groupBy(array, 'category');\n * console.log(grouped); // { A: [{ category: 'A', value: 1 }, { category: 'A', value: 3 }], B: [{ category: 'B', value: 2 }] }\n */\nexport const groupBy = <T>(array: T[], key: keyof T): Record<string, T[]> =>\n    array.reduce((result, currentValue) => {\n        const groupKey = currentValue[key] as unknown as string;\n        if (!result[groupKey]) {\n            result[groupKey] = [];\n        }\n        result[groupKey].push(currentValue);\n        return result;\n    }, {} as Record<string, T[]>);\n\n/**\n * Checks if an object is empty.\n * @param {object} obj - The object to check.\n * @returns {boolean} True if the object is empty, false otherwise.\n * @example\n * isEmptyObject({}); // true\n * isEmptyObject({ a: 1 }); // false\n */\nexport const isEmptyObject = (obj: object): boolean =>\n    Object.keys(obj).length === 0 && obj.constructor === Object;\n\n/**\n * Formats a number as currency.\n * @param {number} value - The number to format.\n * @param {string} [currency='USD'] - The currency code.\n * @returns {string} The formatted currency string.\n * @example\n * formatCurrency(1234.56); // '$1,234.56' (use local currency by default)\n * formatCurrency(1234.56, 'USD', 'en-US'); // '$1,234.56'\n * formatCurrency(1234.56, 'EUR', 'en-GB'); // '€1,234.56'\n */\nexport const formatCurrency = (value: number, currency?: string, locales?: string): string =>\n    new Intl.NumberFormat(locales, { style: 'currency', currency }).format(value);\n\n/**\n * Capitalizes the first letter of a string.\n * @param {string} str - The string to capitalize.\n * @returns {string} The capitalized string.\n * @example\n * capitalize('hello'); // 'Hello'\n */\nexport const capitalize = (str: string): string =>\n    str.charAt(0).toUpperCase() + str.slice(1);\n\n/**\n * Compares two arrays for equality.\n * @param {T[]} a - The first array.\n * @param {T[]} b - The second array.\n * @returns {boolean} True if the arrays are equal, false otherwise.\n * @example\n * arraysEqual([1, 2, 3], [1, 2, 3]); // true\n * arraysEqual([1, 2, 3], [1, 2, 4]); // false\n */\nexport const arraysEqual = <T>(a: T[], b: T[]): boolean =>\n    a.length === b.length && a.every((v, i) => v === b[i]);\n\n/**\n * Generates a random string of specified length.\n * @param {number} length - The length of the string.\n * @returns {string} The random string.\n * @example\n * const randomStr = randomString(5);\n * console.log(randomStr); // e.g., 'abcde'\n */\nexport const randomString = (length: number): string =>\n    Math.random().toString(36).substring(2, length);\n\n/**\n * Parses a query string into an object.\n * @param {string} queryString - The query string to parse.\n * @returns {Record<string, string>} The parsed object.\n * @example\n * const obj = parseQueryString('?a=1&b=2');\n * console.log(obj); // { a: '1', b: '2' }\n */\nexport const parseQueryString = (queryString: string): Record<string, string> =>\n    queryString.replace(/^\\?/, '').split('&').reduce((acc, pair) => {\n        const [key, value] = pair.split('=');\n        acc[decodeURIComponent(key)] = decodeURIComponent(value || '');\n        return acc;\n    }, {} as Record<string, string>);\n\n"
  ],
  "mappings": "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",
  "debugId": "FDF301B39A5A868B64756e2164756e21",
  "names": []
}